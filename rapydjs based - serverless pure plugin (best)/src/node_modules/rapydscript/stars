# CALL
a(*a)
a.apply(this, [a])

a(a, b, *c)
a.apply(this, [a, b].concat([c]))

a(**a)
kwargs(a)(a)

a(a, b, **c)
kwargs(a)(a, b, c)

a(*a, **b)
kwargs(a).apply(this, a.concat(b))

a(c, *a, **b)
kwargs(a).apply(this, [c].concat(a, b))

obj.fun(a, **d)
kwargs(obj.fun)(a, d)

obj.fun(a, b, *c, **d)
kwargs(obj.fun).apply(obj, [a, b].concat(c, d))

o = Class(a, **b)
o = new Class; kwargs(o.__init__).call(o, a, b)

o = Class(a, *c)
o = new Class; o.__init__.apply(o, [a].concat(c))

o = Class(a, *c, **b)
o = new Class; kwargs(o.__init__).apply(o, [a].concat(c, b))

# presence of *args always converts call to .apply()
# *args on class method uses object name as first argument, on a function, it uses 'this'
# presence of **kwargs curries function in a kwargs() call
# presense of arg=val argument groups all such arguments into **kwargs and curries function call the same way
# **kwargs must always be passed in as last argument, even with *args
# if call is a constructor, presence of either *args or **kwargs requires different initialization (due to obstruction of 'new' via kwargs() wrapper or apply())

# currently, everytime kwargs() is invoked, the last argument is a kwargs, so no need for safety yet


# DEFINITION
# **kw just says that user may pass in a plethora of additional optional fields
# **kw in itself is optional, use cases:
#	kw is omitted: normal function
#	kw is included: kw stores any extra args not used up (not assigned) - passthrough (safety needed)
# idea:
#	since all **kw functions will be invoked kwargishly, we know last element will always be kwargs
#	we just don't know if it needs to be passed or discarded, we could always pass it as 99th arg and have function ignore it
#	(CANT, arguments strips extra array stuff) or better yet, just add .kwargs var to kw array passed through kwargs decorator
#		- 99th arg is very slow (http://jsperf.com/rapydscript-nth-argument-added/3)
# idea2:
#	attach kwargs to function in kwargs decorator (problem: cleanup)
#		regular function doesn't care: good
#		special function will check: if set, it could be kwargs or last run? no but function has no way to reference self
#		can use 'this' passed to function instead, 
def a(a, *b):

def a():
    a = arguments[0]
    b = [].concat(args) # may need to remove prefixes


def a(a, **c):

def a(a):
    c = arguments[-1] # if last arg is a hash


def a(a, *b, **c):

def a():
    ...
    b = [].concat(args)
    c = b.pop()

# explicit + implicit kwarg merge:
#	use RS_mixin:
#		kw, kw['arg'] = val					# PROBLEM: kw is modified
#
